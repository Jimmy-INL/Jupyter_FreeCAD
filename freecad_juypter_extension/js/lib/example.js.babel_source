var widgets = require('@jupyter-widgets/base');
var _ = require('lodash');


// Custom Model. Custom widgets models must at least provide default values
// for model attributes, including
//
//  - `_view_name`
//  - `_view_module`
//  - `_view_module_version`
// 
//  - `_model_name`
//  - `_model_module`
//  - `_model_module_version`
//
//  when different from the base class.

// When serialiazing the entire widget state for embedding, only values that
// differ from the defaults will be specified.

// Custom View. Renders the widget model.

var FirstModel = widgets.DOMWidgetModel.extend({
    defaults: _.extend(widgets.DOMWidgetModel.prototype.defaults(), {
        _model_name : 'FirstModel',
        _view_name : 'FirstView',
        _model_module : 'first-widget',
        _view_module : 'first-widget',
        _model_module_version : '^0.1.0',
        _view_module_version : '^0.1.0',
        value : 'Hello World'
    })
});

var FirstView = widgets.DOMWidgetView.extend({
    callback:function(inputEvent, formElement){
        this.model.set({'value':formElement[0].value})    // update the JS model with the current view value
        this.touch()   // sync the JS model with the Python backend
    },

    render: function() {
        this.model.on('change:value', this.value_changed, this);

        let view = this;
        
        // standard HTML DOM change from JS
        let f = document.createElement("form");
        let i = document.createElement("input"); // input element, text            
        i.setAttribute('type',"text");              
        f.appendChild(i);
        this.el.appendChild(f);
        let title = document.createElement("h3");            
        this.el.appendChild(title);
        
        // initializing the form and the title values  
        i.setAttribute('value', this.model.get('value'));
        title.textContent = this.model.get('value');
        
        // Listening to changes in the frontend input
        f.addEventListener("input", (inputEvent => view.callback(inputEvent, f)), false);

        // handle to access the DOM elements directly
        this.input = i;  
        this.title = title;
    },



    value_changed: function() {
        // access to the 'input' DOM element
        this.input.setAttribute('value', this.model.get('value'))
        // access to the 'h3' DOM element
        this.title.textContent = this.model.get('value')

    }
});


var THREE = require("three");

import {
    BlackboxModel
} from 'jupyter-threejs';


const atomGeometry = new THREE.SphereBufferGeometry(0.2, 16, 8);
const atomMaterials = [
    new THREE.MeshLambertMaterial({color: 'red'}),
    new THREE.MeshLambertMaterial({color: 'green'}),
    new THREE.MeshLambertMaterial({color: 'yellow'}),
    new THREE.MeshLambertMaterial({color: 'blue'}),
    new THREE.MeshLambertMaterial({color: 'cyan'}),
];

class CubicLatticeModel extends BlackboxModel {
    defaults() {
        return {...super.defaults(), ...{
            _model_name: 'CubicLatticeModel',
            _model_module: 'my_module_name',
            basis: [[0, 0, 0]],
            repetitions: [5, 5, 5],
        }};
    }

    // This method is called to create the three.js object of the model:
    constructThreeObject() {
        const root = new THREE.Group();
        // Create the children of this group:
        // This is the part that is specific to this example
        this.createLattice(root);
        return root;
    }

    // This method is called whenever the model changes:
    onChange(model, options) {
        super.onChange(model, options);
        // If any of the parameters change, simply rebuild children:
        this.createLattice();
    }

    // Our custom method to build the lattice:
    createLattice(obj) {
        obj = obj || this.obj;

        // Set up the basis to tile:
        const basisInput = this.get('basis');
        const basis = new THREE.Group();
        for (let i=0; i < basisInput.length; ++i) {
            let mesh = new THREE.Mesh(atomGeometry, atomMaterials[i]);
            mesh.position.fromArray(basisInput[i]);
            basis.add(mesh);
        }

        // Tile in x, y, z:
        const [nx, ny, nz] = this.get('repetitions');
        const children = [];
        for (let x = 0; x < nx; ++x) {
            for (let y = 0; y < ny; ++y) {
                for (let z = 0; z < nz; ++z) {
                    let copy = basis.clone();
                    copy.position.set(x, y, z);
                    children.push(copy);
                }
            }
        }

        obj.remove(...obj.children);
        obj.add(...children);
    }
}

module.exports = {
    CubicLatticeModel : CubicLatticeModel,
    FirstModel : FirstModel,
    FirstView : FirstView
};
